import { createStore } from 'redux';
import { connect, Provider }  from 'react-redux';

import { d$referencer } from './json-deref-util.js';
import RandArrayProto from './array-random.js';
import rawSentences from './raw-sentences';
import queryString from 'query-string';

RandArrayProto(Array);

let HappyRedux : any = {};

HappyRedux.connectScore = (Score) => connect(
	(state) => ({
		value : state.game.score
	}),
	() => ({}),
)(Score);

const TRY_CLAUSE = 'TRY_CLAUSE';
const tryClause = ({clauseRef}) => ({
	type : TRY_CLAUSE,
	clauseRef
});

const INIT = 'INIT';
const initAction = () => ({
	type : INIT
});

const START = 'START';
const startAction = () => ({
	type : START
})  

// let defaultSentencesRaw = [
//     [['Haters gonna hate.', 'Why you so mean?', 'Fuck you!'], ['I understand meanness', 'I am enraged by meanness', 'I am intimidated by meanness'], ['is just insecurity.', 'needs revenge.', 'hurts my status.']],
//     [['We get it.', 'You\'re weird', 'I\'m weird.'], ['We both', 'Only you', 'Only I'], ['understand', 'are confused by', 'hate'], ['each other\'s', 'only your', 'only my'], ['experiences.', 'strangeness.']],
//     [['I got game.', 'I\'m so awkward.', 'I\'m so ashamed'], ['People are at ease with,', 'People are freaked out by,', 'People make fun of,'], ['my confident,', 'my pompous,', 'my asinine,'], ['calm,', 'nervous,', 'spastic,'], ['friendly manner.', 'standoffish manner.', 'belligerent manner.']],
//     [['Fun times.', 'This is serious!', 'Boring.'], ['I think of creative ways', 'I don\'t know what to do', 'I hate everyone'], ['to play,', 'to humiliate people,', 'to hurt someone,'], ['have fun,', 'work, work, work,', 'cry,'], ['and include everyone.', 'and exclude losers.', 'and leave in a huff.']],
//     [['How you do\'in?', 'Wanna fuck?', 'Hey bitch!'], ['I flirt', 'I offend', 'I run away'], ['in a friendly,', 'in a creepy,', 'in an awkward,'], ['appropriate ways.', 'obnoxious ways.', 'aggressive ways.']],
//     [['Friends everywhere!', 'Enemies everywhere!', 'Spies everywhere!'], ['I imagine everyone\'s', 'I know no one\'s'], ['my friend', 'my enemy', 'a serial killer'], ['and make conversation', 'and stare ahead', 'and fidget'], ['everywhere.', 'nowhere.']],
//     [['That\'s cool.', 'So annoying.', 'Fuck you!'], ['I understand annoy things', 'I hate annoying things', 'I\'m made apoplectic by annoying things'], ['are just my insecurities', 'are because others are stupid'], ['which I can overcome.', 'which don\'t exist.', 'which will sink me.']],
//     [['I am relaxed', 'I am nervous', 'I am agitated'], ['and confident', 'and self-conscious', 'and meek'], ['around people', 'when alone', 'around assholes'], ['including hot women.', 'including ugly women.']],
//     /* get people to open up */ [['I get people to open up', 'I get people to close off', 'I force people to conceal'], ['by sharing with them', 'by bragging to them', 'by yelling at them'], ['appropriately and', 'inappropriately and', 'improperly and'], ['listening to them.',  'ignoring them.', 'rejecting them.']],
//     [['I am charmed', 'I am annoyed', 'I hate'], ['by people\'s quirks.', 'by asshole\'s flaws.', 'by your stupidity.']],
//     [['You\'re special.', 'Who are you?', 'Go away.'], ['I give people my attention', 'I ignore people', 'I\'m too busy for people'], ['because they are important to me.', 'to manipulate them.', 'to get them off my back.']],
// ];

const getEntities = ({sentencesRaw}) => {
	let d$ref = d$referencer({
		sentences : [],
		clauseChoices : [],
		clauses : [],
	});

	sentencesRaw.forEach((sentenceRaw, i) => {
		let clauseChoiceRefs = sentenceRaw.map((clauseChoiceRaw, j) => {
			let clauseRefs = clauseChoiceRaw.map((clauseRaw, k) => {
				let isCorrect = k === 0;
				
				return d$ref.push('clauses', {
					text : clauseRaw,
					isCorrect
				}).d$self;
			});

			return d$ref.push('clauseChoices', {
				clauseRefs,
				indexInSentence : j,
			}).d$self;
		});

		d$ref.push('sentences', {clauseChoiceRefs});
	});

    return d$ref.data;
};

const getInitialState = ({sentencesRaw} = {}) => {
    if (sentencesRaw === undefined) {
        let sentenceGroup;

        try {
            sentenceGroup = queryString.parse(document.location.search).sentenceGroup;
        }
        catch (error) {
            if (error instanceof ReferenceError) {
                // guess we're not in the browser
                // don't do anything, will deal with this below
            }
            else {
                throw(error);
            }
        }

        if (sentenceGroup === undefined) {
            // either we're not in the browser or
            // this the query parameter wasn't set
            sentenceGroup = 'default'; 
        }

        sentencesRaw = rawSentences[sentenceGroup];
    }

	const entities = getEntities({sentencesRaw});
	const d$ref = d$referencer(entities);

	const activeSentence = entities.sentences.randomElement();
	const firstClauseChoice = d$ref(activeSentence.clauseChoiceRefs[0])
	const activeClauseRefs = firstClauseChoice.clauseRefs.shuffle();

	return {
		entities,
		game : {
			score : 0,
			activeSentenceRef : activeSentence.d$self,
			activeClauseRefs : [],
			activeClauseChoiceInSentence : 0,
			chosenClauseRefs : [],
            pastSentences : [],
			started : true
		},
	};
};

const initial = {
    // can be overidden, making this a reference
    state : getInitialState()
};

const happyGameApp = (state = initial.state, action) => {
	const d$ref = d$referencer(state.entities);

	switch (action.type) {
		case TRY_CLAUSE :
			const gameState = state.game;

			let newGameState = {
				...gameState,
				chosenClauseRefs : [...gameState.chosenClauseRefs]
			};

			const selectedClause = d$ref(action.clauseRef);

			if(selectedClause.isCorrect) {
				newGameState.score += 10;
				newGameState.chosenClauseRefs.push(selectedClause.d$self);
				newGameState.activeClauseChoiceInSentence++;
				let activeSentence = d$ref(newGameState.activeSentenceRef);

                if (newGameState.activeClauseChoiceInSentence >= activeSentence.clauseChoiceRefs.length) {
                    newGameState.activeClauseChoiceInSentence = 0;
                    activeSentence = state.entities.sentences.randomElement();
                    newGameState.activeSentenceRef = activeSentence.d$self;
                    newGameState.pastSentences.push({chosenClauseRefs : newGameState.chosenClauseRefs})
                    newGameState.chosenClauseRefs = [];
                }

                const nextClauseChoice = d$ref(activeSentence.clauseChoiceRefs[ newGameState.activeClauseChoiceInSentence ])
                newGameState.activeClauseRefs = nextClauseChoice.clauseRefs.shuffle();
			};

			return {
				...state,
				game : newGameState
			};
		// case START :
		// 	const gameState = state.game;

		// 	let newGameState = {
		// 		...gameState,
		// 		chosenClauseRefs : [...gameState.chosenClauseRefs]
		// 	};
			
		default : // including INIT
			return state;
	}
}

HappyRedux.createStore = () => createStore(happyGameApp)

HappyRedux.connectActiveClause = (ActiveClause) => connect(
	(state, ownProps) => ownProps,
	(dispatch) => ({
		onClick : ({clauseRef}) => {
			dispatch(tryClause({clauseRef}))
		}
	})
)(ActiveClause);

HappyRedux.connectActiveClauseChoice = (ActiveClauseChoice) => connect(
	(state) => {
		const d$ref = d$referencer(state.entities);

		const { activeClauseRefs } = state.game;

		const clauses = activeClauseRefs.map((clauseRef) => {
			const {text, d$self} = d$ref(clauseRef); 
			return {
				text,
				$ref : d$self.$ref
			};
		});

		return {clauses};
	},
	() => ({})
)(ActiveClauseChoice);

HappyRedux.connectHappyCurrentSentence = (HappyCurrentSentence) => connect(
	(state) => { // stat2props
		const d$ref = d$referencer(state.entities);

		const activeSentence = d$ref(state.game.activeSentenceRef);
		const chosenClauses = state.game.chosenClauseRefs.map(
			(clauseRef) => d$ref(clauseRef)
		);

		const displayClauses = activeSentence.clauseChoiceRefs.map((_, i) => {
			return i < chosenClauses.length ? chosenClauses[i].text : '_____';
		});

		return {displayClauses};
	},
	() => ({}) // dispatch
)(HappyCurrentSentence);

HappyRedux.connectPastSentences = (PastSentences) => connect(
    (state) => {
        let d$ref = d$referencer(state.entities);

        let pastSentencesFromState = state.game.pastSentences;

        let sentences = pastSentencesFromState.map((pastSentence) => {
            let displayClauses = pastSentence.chosenClauseRefs.map((clauseRef) => {
                let {text} = d$ref(clauseRef);

                return {text};
            })
            return {displayClauses};
        })

        return {sentences};
    },
    () => ({}) // dispatch
)(PastSentences);

HappyRedux.connectStartButton = (StartButton) => connect(
	(state) => ({started : state.game.started}), // map state to props
	() => ({}) //dispatch
)(StartButton);

export const testing = {
    tryClause,
    getInitialState,
    initial
};

export default HappyRedux;